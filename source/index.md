---
title: TridentSDK Docs

language_tabs:
  - shell
  - java

toc_footers:
  - <a href='https://tridentsdk.net'>TridentSDK Website</a>
  - <a href="http://tridentsdk.github.io/Javadocs/">Javadocs</a>
  - <a href='https://github.com/TridentSDK'>TridentSDK on GitHub</a>
  - <a href='https://twitter.com/TridentSDK'>Follow Us on Twitter</a>
  - <a href='http://github.com/AgentTroll/slate'>Contribute to the Docs</a>
  - <a href='http://github.com/tripit/slate'>Generated by Slate</a>

includes:

search: true
---

# Introduction

<aside class="notice">
Welcome to the TridentSDK Documentation site.
</aside>

The TridentSDK team is composed of a group of Java developers from the Bukkit API. Trident is a cleanroom implementation of the Minecraft server, which will improve server performance, flexibility, and simplicity. 

TridentSDK is a successor to the Bukkit/Spigot projects. Following the news of the "takeover" of the Bukkit project and the DMCA takedown of Bukkit, and therefore Spigot (we are quite aware of binary patches), we realized that someone needs to step up and create a server for Minecraft after the decline of both projects. The result was TridentSDK, the development kit that is implemented by the server, Trident.

## How to use the documentation

You may be seeing just annotations in some parts of this document. This is because there are language tabs where you can switch which language the examples are in. Unlisted means that there is no support for the particular language (which are shell and Java at the moment). If you aren't seeing the code on mobile, scroll up the sidebar, then press the other language. If you are on a desktop, on the top right is the language tabs, simply click the tab you wish to view.

# Features

Feature | Explanation | Other servers
------- | ----------- | -------------
Developers | We are top-of-the-line developers from the Bukkit API | &#x2717;
Community | We are active community members and have high-profile connections to other developers | &#x2717;
Cleanroom | Legally stable, performance-oriented, controlled, simple | &#x2717;
Multithreaded | Effectively utilizes modern CPUs | &#x2717;
Tested | Published with results, all aspects and benchmarks + comparison included | &#x2717;
Pace | Development occurs nearly everyday | &#x2717;

# Installation

Because TridentSDK is currently a high-paced work in progress, and the reimplementation of the entire Minecraft server is time-consuming, there are no builds available to use. The server does not work at the moment. You will need to download the source and compile it yourself.

## Prerequisites

To install Trident, you should have the following installed on your system:

* [JDK 7](https://docs.oracle.com/javase/7/docs/webnotes/install/) 
* [Maven](http://maven.apache.org/download.cgi)
* [Git](http://git-scm.com/downloads)

## Source download

> To download the server source, use:

```shell
git clone https://github.com/TridentSDK/Trident.git
```

> To compile the final jar, use:

```shell
cd Trident
mvn clean install
```

After completing the above steps, you should be in `Trident/target`, with a fully compiled jar that can be run from the command line to start your server. Use the `jar-with-dependences`, or the dependencies will not be satisfied.

## Troubleshooting

#### Command not found

TridentSDK is developed primarily on Unix-based (Ubuntu, Debian) systems. Other Operating Systems may have directions that differ slightly, look them up for your own Operating System.

If your command starts with `git`, `mvn`, or `javac`, then you either need to install, or reinstall the tools in [Prerequisites](#prestiques).

Another problem may be that you have not set your PATH environment variables yet. This is covered in the Prerequisites links.

#### Paths cannot be resolved

Just edit `..` to your primary directory where you executed your git commands at

#### Where is my jar file?

It's in the working directory of the command line. For Unix-based systems, this is often in your Home directory. For Windows, this is the user directory. Therefore, it is recommend to change directory to your desktop or other place that is convenient and memorable.

## Updating

We are currently planning an update mechanism built into the server. However, it has not yet been implemented. Using Trident requires executing the above steps, a monolithic (i.e. jar-file) release will be available in the near future.

```shell
# Remove old files
rm -r Trident

# Download again
git clone https://github.com/TridentSDK/Trident.git
```

> Now go to [Source download](#source-download) and use the `To compile the final jar` steps.

# Contributing

On the left, near the bottom, there are a few links. Currently, there are 3 portions of the project that are open to community involvement.

### Code
First, we need help with the source. The highest priority right now is player joining, which we have the protocol and world loading facilities that are mature enough to be used for the purpose. The protocol is very elusive, and if you have used it before, help would be appreciated. Head over to our GitHub page, or tweet to us to find out how to help (pull requests on our repository are always welcome!).

### Documentation
Second, we will need help with documentation. There are two places where documentation is needed - here, and in the source. Javadocs are largely incomplete, as moving forward with development, getting performance testing, and finishing the server basics are of highest priority. We would greatly appreciate extra hands on source documentation. The documentation here is how to use the API, not what each method does. Head over to the Contribute to the Docs and submit a PR to the index.md on master, and we can recompile the site. Or, head over to the GitHub and submit a PR to add documentation comments to the methods.

### Community
Third is community administration. As we do not have a large community yet, the greatest help is achieved through sharing TridentSDK with your friends and other users. Later on, when TridentSDK becomes mature, you may apply for administrative positions. 

# API

TridentSDK provides an extensive API for developing server modifications that can be used to modify game play that is controlled by the server. Trident does not provide for client side modifications.

## Prerequisites

* [A Java IDE](http://en.wikibooks.org/wiki/Java_Programming/Java_IDEs)
* [JDK 7](https://docs.oracle.com/javase/7/docs/webnotes/install/) 
* [Maven](http://maven.apache.org/download.cgi)
* [Git](http://git-scm.com/downloads)
* 'Thorough understanding of the Java Language'

## Starting

As well as the items in the prerequisites above, it is **imperative** that you have a thorough understanding of the Java programming language.

While Trident can be used with any IDE, as it is simply a library, the TridentSDK team recommends Intellij IDEA from JetBrains.

Before getting started, you should read over the Javadocs for Trident (link on the lower left of this page).

## Setup

> Getting TridentSDK

```shell
git clone https://github.com/TridentSDK/TridentSDK.git
cd TridentSDK
mvn clean install
```

To begin, pull from our `TridentSDK` repository and compile it. The jarfile can be found in the `target` folder after running `mvn clean install`. 

Then, start up your IDE, you should be familiar with your development environment. Create a new project, and add the TridentSDK dependency to your workspace.

## Creating the main class

> Extend `TridentPlugin`

```java
package com.example.smite;

import net.tridentsdk.plugin.TridentPlugin;

public class Smite extends TridentPlugin {

}
```

> Annotate with `PluginDescription`

```java
package com.example.smite;

import net.tridentsdk.plugin.TridentPlugin;
import net.tridentsdk.plugin.annotation.PluginDescription;

@PluginDescription(name = "Project", author = "Pierre C", version = "6.9")
public class Smite extends TridentPlugin {

}
```

> Use lifecycle methods

```java
package com.example.smite;

import net.tridentsdk.plugin.TridentPlugin;
import net.tridentsdk.plugin.annotation.PluginDescription;

@PluginDescription(name = "Project", author = "Pierre C", version = "6.9")
public class Smite extends TridentPlugin {
    @Override public void onEnable() {
    }

    @Override public void onLoad() {
    }

    @Override public void onDisable() {
    }
}
```

The first step in development of a Trident plugin is to create the main class. This is where all of your plugin's functional aspects are initialized. Create a new package titled with your domain, backwards. For example, if you own `example.com`, then your package would be `com.example.&lt;project&gt;`, where `project` is the project's name, in our example it is `smite` . This does not affect functionality. If you do not own a domain, you may use your email. For example, if you owned `someone@random.com`, then use `com.random.someone`. If your email contains a `-` character, use an underscore (`_`) instead.

<aside class="warning">
DO NOT use the package name `net.tridentsdk.*`. Any package name beginning with this pattern will not have its classes loaded, thereby rendering the plugin useless.
</aside>

Then, create a new Java class, with a meaningful name (the class name does not affect functionality). This class must extend TridentPlugin (i.e. declaration ends in `extends TridentPlugin`).

----

Then, you must add a PluginDescription annotation to your class to mark the plugin parameters.

Of course, replace the name with the name of the project (does not affect functionality), the author with your name/username/online name/alias (does not affect functionality), and the version with the plugin version (does not affect functionality).

The only required field in a PluginDescription annotation is the plugin name (`name`).

----

`TridentPlugin` provides several methods that are executed during various events in a plugin's lifecycle. They are called in this order: `onLoad`, `onEnable`, `onDisable`. `onLoad` is called shortly after the plugin object is created, before any world loading takes place, and before any plugins are enabled. `onEnable` is called when the plugin is enabled, after Trident has finished initializing, worlds are loaded, and all plugins have had their `onLoad` method invoked. Finally, `onDisable` is called when the plugin is disabled, either due to an error or server shutdown.

These methods may be overridden to execute code at specific lifecycle events. They are not required, and if you don't need them, you should not override them.

## Commands

> Implementing a proper command

```java
package com.example.smite;

import net.tridentsdk.api.entity.living.Player;
import net.tridentsdk.plugin.cmd.Command;
import net.tridentsdk.plugin.cmd.CommandIssuer;
import net.tridentsdk.plugin.cmd.ConsoleSender;

public class Smite extends Command {
    @Override public void handlePlayer(Player player, String arguments, String alias) {
    }

    @Override public void handleConsole(ConsoleSender sender, String arguments, String alias) {
    }
    
    @Override public void handle(CommandIssuer sender, String arguments, String alias) {
    }
}
```

<aside class="warning">
'DO NOT' register your commands explicitly unless they do not work. Doing so may result in your command being executed twice.
</aside>

Commands are implemented by subclassing the `Command` class (net.tridentsdk.plugin.cmd.Command). In order to handle commands, there are 3 methods provided to check for commands. They are `handle`, `handlePlayer`, and `handleConsole`. The `handle` method is invoked when anything executes this command (e.g. command block, player, console). `handlePlayer` only handles player executed commands, and `handleConsole` only handles console commands. 

<aside class="notice">
If a class has both a 'handle' and 'handlePlayer' method, both will be invoked when a player executes a command (`handleConsole` has similar behavior). The 'handlePlayer' and 'handleConsole' methods are largely provided as convenience methods and are not mutually exclusive to the 'handle' method being invoked.
</aside>

The first parameter passed to the handle method is the issuer of the command. This can be any subclass of CommandIssuer in `handle`, which may be checked by using `instanceof` for the Player or ConsoleSender classes (or any other subclasses). The second parameter is args, which is the line the sender entered, without the command itself (for example, /basic spawn would have args `spawn`, and /smite leetplayer 100 would have args `leetplayer 100`). Finally, the alias is the command executed, the first word after `/` in the command box. Each argument has its own documentation in the pertinent classes. 

## Events

> This is a proper event listener

```java
package com.example.smite;

import net.tridentsdk.api.event.entity.EntityDeathEvent;
import net.tridentsdk.api.event.Listener;

public class Project implements Listener {
    public void onEvent(EntityDeathEvent event) {
    }
}
```

> This is a proper way to prioritize events:

```java
package com.example.smite;

import net.tridentsdk.api.event.entity.EntityDeathEvent;
import net.tridentsdk.api.event.Call;
import net.tridentsdk.api.event.Importance;
import net.tridentsdk.api.event.Listener;

public class SmiteListener implements Listener {
    @Call(Importance.LOWEST)
    public void onEvent(EntityDeathEvent event) {
    }
}
```

> Implementing event ignorance

```java
Event event = new EntityDeathEvent(/* Your values */);
EventManager.call(event);
if (event.isIgnored()) {
    // Do what you need to do if the event is cancelled
} else {
    // Proceed
}
```

> Ignoring events

```java
package com.example.smite;

import net.tridentsdk.api.event.entity.EntityDeathEvent;
import net.tridentsdk.api.event.Listener;

public class SmiteListener implements Listener {
    public void onEvent(EntityDeathEvent event) {
        event.cancel(true);
    }
}
```

Unlike the Bukkit event system, events in Trident are automatically registered. You should not explicitly register your events.

<aside class="warning">
DO NOT register your events explicitly unless they do not work otherwise. Doing so may result in the event being called twice.
</aside>

The requirements for an event method is that it must be a publicly visible method that returns void and be in a class implementing `Listener` (`net.tridentsdk.api.event.Listener), and the method must have a single parameter that is superclassed by Event.

<aside class="notice">
You can prevent your method from being registered in a class implementing Listener by marking the method with `@IgnoreRegistration`, alternatively, classes may also be marked `@IgnoreRegistration` to prevent any methods in the class from being used as listeners.
</aside>

Events usually have self-descriptive class names, for example, EntityDeathEvent occurs when an entity dies, of course, it must be a LivingEntity.

Events can be removed from the event caller list using [`EventManager#unregister(Listener)`](http://tridentsdk.github.io/Javadocs/net/tridentsdk/api/event/EventManager.html#unregister(net.tridentsdk.api.event.Listener)), where `Listener` represents an instance of the listener that was registered into the list.

----

Event priorities are annotated by a `@Call` annotation, which takes a single parameter, `Importance`.

Events are called in this order: `LOWEST`, `LOW`, `MEDIUM`, `HIGH`, `HIGHEST`. This occurs because the most important events must edit what the other plugins have set to the event. If 2 events have the same priority, then there is no guaranteed order. If the event does not have a `@Call` annotation, then the importance is automatically set to `Importance.MEDIUM`.

Importance is valuable in APIs, where you'd want to check in with events, but not edit them, and allow other plugins to view event modifications made by the API, as well as providing higher level plugins to have control over the event result.

----

Events that `implement Cancellable` where Cancellable is `net.tridentsdk.api.event.Cancellable` can be used to prevent and implement cancellation functionality. To provide cancellation functionality for your event, simply `implement Cancellable`, overriding the two new methods to modify a `boolean` field, which is checked when the event is called. Events are called using [`EventManager#call(Event)`](http://tridentsdk.github.io/Javadocs/net/tridentsdk/api/event/EventManager.html#call(net.tridentsdk.api.event.Event)). After calling, check the event object using `isIgnored()`, which returns `true` if the event should be cancelled.

For the API user, you may cancel an event, which will create behavior specified in the cancellation policy by calling [`Cancellable#cancel(boolean)`](http://tridentsdk.github.io/Javadocs/net/tridentsdk/api/event/Cancellable.html#cancel(boolean)). The boolean value is true if the event should be cancelled, or false to prevent the event from being cancelled by lower priority listeners. You can check if the event has been cancelled before it reached the current listener using [`Cancellable#isIgnored()`](http://tridentsdk.github.io/Javadocs/net/tridentsdk/api/event/Cancellable.html#isIgnored()), which returns true if the event should be ignored.

<aside class="warning">
Some Events do not implement `Cancellable`. Check the docs!
</aside>

## Configuration

> Correctly creating a configuration file, or multiple.

```java
import net.tridentsdk.api.config.JsonConfig;
import net.tridentsdk.api.factory.Factories;

public class Project extends TridentPlugin {
    private final JsonConfig config =
            Factories
            .configs()
            .createConfig(this.getConfigDirectory() + "/configuration.json");
    private final JsonConfig anotherConfig =
            Factories
            .configs()
            .createConfig(this.getConfigDirectory() + "/players.json")
}
```

> Deleting your file

```java
try {
    Files.delete(config.getPath());
} catch (IOException e) {
    e.printStackTrace();
}
```

> Reloading the configuration

```java
config.reload();
```

> Proper JSON format for TridentSDK

```json
{
    // Normally JSON does not allow comments
    // however, Trident's JSON parser 
    // allows for comments
    // use two forward slashes to create 
    // comments in your configuration,
    // similar to this comment

    "here is a key": "this is a string value",
    "append , after key-value": 10,
    "you can have doubles too": 0.6,

    "this is a section": {
        "it has more key-values": 10,
        "you can also have lists": 10
    },

    "this is a list": [
        "there are values in lists",
        "they have brackets instead of braces",
        "and you still use commas to separate entries"
    ],
    
    "usually you want no spaces in your keys": 10,
    "ThisIsAKey": 10,
    "your last entry doesn't have a comma": "enjoy using json"
}
```

The TridentSDK configuration is similar to that of the Bukkit configuration, however, we use JSON instead of YAML. JSON has a slightly more complex syntax than YAML, however, it does not have the same constraints (such as lack of tabs, spacing, etc). 

Each `TridentPlugin` has a configuration directory to hold files the plugin may have. This can be accessed using `TridentPlugin#getConfigDirectory()`, returned as a `File`. This file is actually a folder.

A configuration file can be created, or retrieved using the `ConfigFactory#createConfig(...)` method, from `Factories#configs()`. More information about `Factories` can be found in the [section below](#factories). If the config specified in createConfig already exists, the data will be loaded into the returned `JsonConfig` object. Otherwise, it will be created for you. The file should have a `.json` file type.

If you wish to remove your configuration, it can be deleted at the path specified in the JsonConfig.

Once the `JsonConfig` constructor is invoked, the object will automatically reload and store the configuration to memory. If the config is changed externally, such as by opening with a text editor, then you must reload the configuration file yourself.

### Getting and setting

Configuration manipulation is handled at `ConfigSection`, where get/set for all primitives, lists, objects, BigInteger, and BigDecimals in the configuration is supported. There is also `contains()`, parent/child section access, and programmatic access to the JSON object form of the configuration, and saving capability. Trident parses without comments, so you can have `//` comments without a problem. The technical documentation for JSON can be found at the [Engineering Task Force website](http://www.ietf.org/rfc/rfc4627.txt). However, most developers can get by with the example provided on the right.

## Factories

The TridentSDK factories API provides a factory to access many of the major components of TridentSDK, especially implementation-specific facilities. Classes that relate to collections, configuration, executors, tasks, threads, and reflection can be accessed from Factories. Factories replace the important methods from the original Bukkit class with a modular API that is easy to understand and access.

Factories are thread-safe. Initialization occurs before any access is done to the `Factories` class, as well as guarding by `HeldValueLatch`, which blocks until the main thread initializes all accessors inside of Factories.

Here is a list of all facilities provided by `Factories`:

  - Tasks
    - Scheduler methods
    - Async
    - Sync
    - Run now
    - Run later
    - Run repeatedly
  - Threads
    - Entity
    - Player
    - World
    - Plugin
    - Executors
  - Configs
    - Server config
    - New `JsonConfig`
    - New `JsonSection`
  - Collections
    - Caches
    - Improved ConcurrentHashMap
  - Reflection
    - Classes
    - Fields
    - Methods
    - Constructor
  - Display information
    - MOTD
    - MOTD image/pictures
    - Max players
    - Player count

# Benchmarks

<aside class="notice">
Nerd section! You don't need this information to make a plugin!
</aside>

TridentSDK is heavily benchmarked. Some of the most performance critical classes, such as the reflection API, scheduling, events, and caching are benchmarked inside the Trident test package.

This is a list of the currently benchmarked classes:

- [Reflection benchmark](http://bit.ly/1vwutXc)
- [ConcurrentHashMapV8 benchmark](http://bit.ly/1y90tml)
- [ConcurrentCache benchmark](http://bit.ly/1A21o5O)
- [EventManager benchmark](http://bit.ly/1B3psZv)
- [Scheduler benchmark](http://bit.ly/12fTNow)

All benchmarks have a baseline benchmark at 0, called *control*. The traditional benchmark, before the update, used straight pounding on the data structure that was being benchmarked. In a realistic situation, this does not happen. Thankfully, we used [JMH](http://openjdk.java.net/projects/code-tools/jmh/), which is feature packed with everything we need to performance test our classes.

One of the features was the `Blackhole` class, which is used in the benchmarking infrastructure to prevent optimization of the harness. Then, there was `Blackhole.consumeCPU(int)`. This is used to amortize the test pounding on the harness, which was used in the tests to improve realism and accuracy of the calculations. 
 
The graphs were a result of 4 hours of work experimenting with Google Charts' [excellent API](https://developers.google.com/chart/). However, there were a couple things that may seem to be off at first. The most apparent incongruity is that there are *negative values*. How is this possible? Let's begin by examining how the charts are generated from the data.

The charts are generated by running `Benchmarks.chart(Benchmarks.parse(Collection<RunResult>, String)`. The `parse` method iterates through the results to find the times and label of the benchmarks. All benchmarks are run with a `control` group, which measures the CPU cycles taken up by the amortization method discussed above. Since each harness runs the consumption method, we have the actual benchmark PLUS the cost of running the amortization. Therefore, we plot the data by subtracting the amortization cost from the total benchmark. HOWEVER, this is not totally accurate. The amortization harness runs independently of the other harnesses, therefore, it may be larger or smaller than the benchmarked value of the particular harness.

Secondly, you may see that if you run the method several times, you'd get different colors (yay). This WILL NOT affect the data produced by the graph. The colors are randomized when generated, so that will not compromise the integrity or the accuracy of the data gathered during the test.

Third, you might also see that control is a straight line... Yes, it is a straight line if you look at the URL data. Control, again, is the amortization cost, which is subtracted by the amortization cost when plotted... So the amortization cost minus the amortization cost is 0.

----

If you'd like to use `Benchmarks` for your own benchmarks, please note the Apache License, and `BenchmarkTemplate` can be used as a starter for your benchmarks. Benchmarking requires a large amount of knowledge on how the Java technologies (GC, JIT, JVM, etc) work. I am not liable for any damages caused by the results I have posted  or generated from my class. They are meant for reference use only. 

Reference article: [Nanotrusting the Nanotime](http://shipilev.net/blog/2014/nanotrusting-nanotime/), by Aleksey Shipil—ëv

## How to read the charts

The charts are in nanoseconds / operation on the Y axis, which corresponds with the amortization cycles for that harness point. 1024 cycles represents light server load, while 1 represents heavy server load. The data for the selected item should fit the load capacity of the server, and the majority of the fastest option. TridentSDK maintains responsiveness by allowing slow registry trade for fast runtime. Lower ns/op is better.

## Why benchmarking matters

The past generation of server software (Bukkit/Spigot), and designs based on them, such as Sponge/Forge/NMS based servers are unable to multi-thread their servers effectively because NMS (net.minecraft.server and related packages) limits their ability to exploit multiple processors. Servers are plagued with "Cannot keep up" warnings, which result from too much work being executed for the given time in a server heartbeat. In order to reduce these warnings, TridentSDK is implemented with multi-threading in mind, breaking free of the bonds imposed by other software to fully utilize the processor efficiently and reduce task execution time to fit more in a single tick.

These tests compare performance of a particular class to previous generation software or library classes (that may or may not have the same semantic functionality as the benchmark comparison). They also help debug classes, as performance issues relate to bugs in the code, or inefficient/over-defensive programming.

Benchmarking also helps make decisions with which option to use, and how well it performs compared to other pieces of software. TridentSDK, is of course, performance focused.


